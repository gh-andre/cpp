#
# github.run_number is maintained per workflow file name. The workflow name may
# change without affecting the run_number counter, but when the file name changes,
# the counter is reset to one. This means that for each new version to have its
# own counter starting from one, the workflow need to be maintained per version
# and copied for each new version, with the old name becoming immutable.
#
# Workflow name won't accept context expressions, such as ${{ github.run_number }}.
#
# Moreover, Actions UI confuses workflow names in different branches and while the
# name will be evaluated properly during the run (e.g. if ${{ github.workflow }}
# is used), the name of the running workflow will replace *all* run names in
# Actions UI, even for different branches, where workflow name is different. This
# makes it impossible to distinguish multiple runs without clicking on them, which
# would show the proper run name.
#
name: Hello World 1.3.0

# manual and REST API runs only
on: workflow_dispatch

env:
  #
  # These version variables are half-measures for tracking build numbers and
  # won't work as well as Azure pipeline names and counters. If this workflow
  # file is reused between branches, build numbers will not be sequential and
  # workflow runs will be messed up in Actions UI (see `name`).
  #
  # Seems that the only way to track  build numbers per branch in GitHub is
  # to have different workflow files, which is a lot of duplication.
  #
  VERSION: 1.3.0
  BUILD_NUMBER: ${{ github.run_number }}
  PKG_REV: ${{ github.event.inputs.PKG_REV }}

jobs:
  build-debian:
    name: Debian Build
    runs-on: ubuntu-latest
    
    steps:
    # checkout the latest source
    - name: Checkout
      uses: actions/checkout@v2

    # use a local action that builds a Debian container and runs `make` in it
    - name: Make ./cpp
      uses: ./.github/workflows/debian-build
      with:
        build_number: ${{ env.BUILD_NUMBER }}

    # run the app to make sure it was built
    - name: test ./cpp
      run: ./cpp
      
    #
    # Use a local action to package build output as a tar/gzip artifact with
    # the application version and build number in the archive name.
    #
    - name: Archive ./cpp
      uses: ./.github/workflows/alpine-archive
      with:
        tar_gz_name: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        file_or_dir_path: ./cpp
    
    # upload the artifact under the `hello-world` name
    - name: Upload ./cpp artifact
      uses: actions/upload-artifact@v2.2.1
      with:
        name: hello-world-deb
        path: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz

  build-windows:
    name: Windows Build 
    runs-on: windows-latest
    strategy:
      matrix:
       build-platform: [x64, Win32]
       include:
         - build-platform: Win32
           vcvars-args: x86
         - build-platform: x64
           vcvars-args: x64
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    # batch file must be prefixed with `call` for this step to work
    - name: build cpp
      shell: cmd
      env:
        VCVARS_ARGS: ${{ matrix.vcvars-args }}
      run: |
        call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsall" %VCVARS_ARGS%
        cl /c /DBUILD_NUMBER=${{ env.BUILD_NUMBER }} test.cpp
        link /OUT:cpp.exe /SUBSYSTEM:CONSOLE test.obj
        
    - name: test cpp
      shell: cmd
      run: cpp

    # 7zip is pre-loaded on Windows VMs
    - name: Archive ./cpp.exe
      shell: cmd
      env:
        PLATFORM: ${{ matrix.build-platform }}
      run: |
        7z a -tzip hello-world-win-%PLATFORM%-%VERSION%+%BUILD_NUMBER%.zip ./cpp.exe
    
    # upload the artifact under the `hello-world` name
    - name: Upload ./cpp artifact
      uses: actions/upload-artifact@v2.2.1
      with:
        name: hello-world-win-${{ matrix.build-platform }}
        path: hello-world-win-${{ matrix.build-platform }}-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip

  release:
    name: Create a draft release for ./cpp
    needs: [build-debian, build-windows]
    runs-on: ubuntu-latest

    steps:
    # create a draft GitHub release
    - name: Create a draft release
      id: create_release
      uses: actions/create-release@v1.1.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ env.VERSION }}
        release_name: v${{ env.VERSION }}
        draft: true

    # download the artifact that was built in the `build` job in this workflow
    - name: Download Debian artifact
      uses: actions/download-artifact@v2.0.7
      with:
        name: hello-world-deb
        path: .

    # upload the build artifact as a draft release asset
    - name: Upload a Debian Release Asset
      uses: actions/upload-release-asset@v1.0.2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # use the upload URL from the step that created a release
        upload_url: ${{ steps.create_release.outputs.upload_url }} 
        asset_path: ./hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        asset_name: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        asset_content_type: application/tar+gzip

      # same steps would be used for the x86 platform (not done in this script)
    - name: Download Windows x64 artifact
      uses: actions/download-artifact@v2.0.7
      with:
        name: hello-world-win-x64
        path: .

    - name: Upload a Windows Release Asset
      uses: actions/upload-release-asset@v1.0.2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # use the upload URL from the step that created a release
        upload_url: ${{ steps.create_release.outputs.upload_url }} 
        asset_path: ./hello-world-win-x64-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip
        asset_name: hello-world-win-x64-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip
        asset_content_type: application/zip
