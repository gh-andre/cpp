#
# github.run_number is maintained per workflow file name. The workflow name may
# change without affecting the run_number counter, but when the file name changes,
# the counter is reset to one. This means that for each new version to have its
# own counter starting from one, the workflow need to be maintained per version
# and renamed for each new version. However, it gets worse, and while  renaming
# the workflow file name in `master` resets the run counter and works well in
# tracking past and new builds on `master`, workflow files in other branches,
# like in branch `1-5` in this repository, are simply ignored, so the same
# technique won't work outside of `master`.
#
# Workflow name won't accept context expressions, such as ${{ github.run_number }}.
#
# Moreover, Actions UI confuses workflow names in different branches and while the
# name will be evaluated properly during the run (e.g. if ${{ github.workflow }}
# is used), the name of the running workflow will replace *all* run names in
# Actions UI, even for different branches, where workflow name is different. This
# makes it impossible to distinguish multiple runs without clicking on them, which
# would show the proper run name. Using per-branch workflow file name seems to be
# the only way around this.
#
name: Hello World 2.0.0

# manual and REST API runs only
on:
  workflow_dispatch:
    inputs:
      TEST_INPUT:
        description: Test input value
        default: ABC
        required: false
env:
  #
  # These version variables are half-measures for tracking build numbers and
  # won't work as well as Azure pipeline names and counters. If this workflow
  # file is reused between branches, build numbers will not be sequential and
  # workflow runs will be messed up in Actions UI (see `name`).
  #
  # Seems that the only way to track  build numbers per branch in GitHub is
  # to rename workflow file name in each branch.
  #
  VERSION: 2.0.0
  BUILD_NUMBER: ${{ github.run_number }}
  PKG_REV: ${{ github.event.inputs.PKG_REV }}

  #
  # Environment mapping cannot be used within another env block,
  # which requires juggling prefixes and suffixes that can be
  # constructed at each level. If we wanted to construct a value
  # from a version, matrix platform and input that can be reused
  # between steps, we would need to construct a suffix from a
  # matrix platform and input and then combine it with version
  # where the full text is required. Alternatively, we can use
  # format like this to make it more descriptive.
  #
  # version, platform
  THREE_PART_VAR_FMT: '{0}/{1}/${{ github.event.inputs.TEST_INPUT }}'

jobs:
  test-matrix-job:
    name: Test Matrix Job 
    runs-on: ubuntu-20.04
    strategy:
      matrix:
       build-platform: [x64, Win32]
       build-config: [Debug, Release]
       include:
       - build-config: Release
         release-only-var: This should appear only in a release build

    #
    # Unlike Azure pipeline variables, evv mappings cannot refer
    # to each other and this definition will generate errors.
    #
    #env:
    # THREE_PART_VAR: '${{ env.VERSION }}/${{ matrix.build-platform) }}/${{ github.event.inputs.TEST_INPUT }}'

    steps:
    - name: Print vars
      run: |
        echo 'VARS: ${{ matrix.build-platform }} ${{ matrix.build-config }}'
        echo 'RELEASE ONLY VAR: ${{ matrix.release-only-var }}'
        echo 'THREE_PART_VAR_FMT: ${{ format(env.THREE_PART_VAR_FMT, env.VERSION, matrix.build-platform) }}'
        echo 'THREE_PART_VAR: ${{ env.VERSION }}/${{ matrix.build-platform) }}/${{ github.event.inputs.TEST_INPUT }}'

  build-debian:
    name: Debian Build
    runs-on: ubuntu-20.04
    
    steps:
    # checkout the latest source
    - name: Checkout
      uses: actions/checkout@v2

    # use a local action that builds a Debian container and runs `make` in it
    - name: Make ./cpp
      uses: ./.github/workflows/debian-build
      with:
        build_number: ${{ env.BUILD_NUMBER }}

    # run the app to make sure it was built
    - name: test ./cpp
      run: ./cpp
      
    #
    # Use a local action to package build output as a tar/gzip artifact with
    # the application version and build number in the archive name.
    #
    - name: Archive ./cpp
      uses: ./.github/workflows/alpine-archive
      with:
        tar_gz_name: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        file_or_dir_path: ./cpp
    
    # upload the artifact under the `hello-world` name
    - name: Upload ./cpp artifact
      uses: actions/upload-artifact@v2.2.1
      with:
        name: hello-world-deb
        path: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz

  build-windows:
    name: Windows Build 
    runs-on: windows-2019
    strategy:
      matrix:
       build-platform: [x64, Win32]
       include:
         - build-platform: Win32
           vcvars-args: x86
         - build-platform: x64
           vcvars-args: x64
    
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    # batch file must be prefixed with `call` for this step to work
    - name: build cpp
      shell: cmd
      env:
        VCVARS_ARGS: ${{ matrix.vcvars-args }}
      run: |
        call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsall" %VCVARS_ARGS%
        cl /c /DBUILD_NUMBER=${{ env.BUILD_NUMBER }} test.cpp
        link /OUT:cpp.exe /SUBSYSTEM:CONSOLE test.obj
        
    - name: test cpp
      shell: cmd
      run: cpp

    # 7zip is pre-loaded on Windows VMs
    - name: Archive ./cpp.exe
      shell: cmd
      env:
        PLATFORM: ${{ matrix.build-platform }}
      run: |
        7z a -tzip hello-world-win-%PLATFORM%-%VERSION%+%BUILD_NUMBER%.zip ./cpp.exe
    
    # upload the artifact under the `hello-world` name
    - name: Upload ./cpp artifact
      uses: actions/upload-artifact@v2.2.1
      with:
        name: hello-world-win-${{ matrix.build-platform }}
        path: hello-world-win-${{ matrix.build-platform }}-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip

  release:
    name: Create a draft release for ./cpp
    needs: [build-debian, build-windows]
    runs-on: ubuntu-latest

    steps:
    # create a draft GitHub release
    - name: Create a draft release
      id: create_release
      uses: actions/create-release@v1.1.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ env.VERSION }}
        release_name: v${{ env.VERSION }}
        draft: true

    # download the artifact that was built in the `build` job in this workflow
    - name: Download Debian artifact
      uses: actions/download-artifact@v2.0.7
      with:
        name: hello-world-deb
        path: .

    # upload the build artifact as a draft release asset
    - name: Upload a Debian Release Asset
      uses: actions/upload-release-asset@v1.0.2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # use the upload URL from the step that created a release
        upload_url: ${{ steps.create_release.outputs.upload_url }} 
        asset_path: ./hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        asset_name: hello-world-deb-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.tar.gz
        asset_content_type: application/tar+gzip

      # same steps would be used for the x86 platform (not done in this script)
    - name: Download Windows x64 artifact
      uses: actions/download-artifact@v2.0.7
      with:
        name: hello-world-win-x64
        path: .

    - name: Upload a Windows Release Asset
      uses: actions/upload-release-asset@v1.0.2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # use the upload URL from the step that created a release
        upload_url: ${{ steps.create_release.outputs.upload_url }} 
        asset_path: ./hello-world-win-x64-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip
        asset_name: hello-world-win-x64-${{ env.VERSION }}+${{ env.BUILD_NUMBER }}.zip
        asset_content_type: application/zip
